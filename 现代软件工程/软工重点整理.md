#### （1）软件的概念，相对于传统的产品有什么区别，软件和硬件相比较而言不会磨损，而会退化

软件概念：软件是逻辑的而非物理的系统元素。包括数据结构，计算机程序，文档（软件描述信息）。

与硬件相比：不会磨损，但会退化

退化的原因：软件会面临不同利益相关者的变更请求，不断出现缺陷。大多数软件是定制的，客户自己都不知道他到底需要什么。



#### （2）软件工程，软件工程的目标，为什么要学习软件工程

​	软件工程包括过程，一系列方法（实践）和大量工具，专业人员借助这些来构建高质量的计算机软件。 

软件工程层次图包括：tools，methods，process model（包括沟通，需求分析，设计建模，程序构造，测试和技术支持）（是基础，包括工作环境，提交工作产品，建立里程碑），quality focus（根基）

​	为什么要学习软件工程：可以是我们高效，高质量地构建复杂系统。使得杂乱无章地工作变得有序，也允许计算机软件的设计者调整其工作方式，以更好地适应要求。

#### （3）软件过程的框架，五个基本的框架活动在不同的模型中采用不同的方式来组织。瀑布模型，快速模型，协同开发模型……不管是什么模型，五个活动总是有的

​	软件工程的过程框架包括：沟通 策划 建模 构建 部署

建模（分析，设计）

构建(编码，测试)

部署(交付，反馈)

​		

#### （4）在框架活动之中，又按照不同的尺度分成了活动、动作和任务（在每一个活动中为了达成一定目的又包含动作）

#### （5）过程模型：瀑布模型、增量模型、演化模型、其他等等模型。各模型的优点，缺陷。在瀑布模型的缺陷之上又有了增量模型，演化模型。演化模型又分为原型模型（主要动机：在需求把握不好的时候）、螺旋模型（在什么时候去使用、主要特点是什么：大型的软件系统的开发……），【并发模型、其他特殊模型作了解就好】

​    瀑布模型：

  1.又称经典生命周期，提出了一个系统的，顺序的软件开发方法，从用户的需求规格说明开始，通过策划，建模，构建和部署的过程最终提供完整的软件支持。

2. 优点：在需求固定且工作要继续完成的情况下是有用的流程模型

3. 缺陷：

   1. 实际的项目很少遵循瀑布模型提出的顺序，随着项目团队的继续，更改可能会导致混乱。
   2. 客户通常难以清楚描述所有需求
   3. 客户必须有耐心，只有在项目接近尾声时，才能得到可执行的程序。

增量模型：

1. 增量模型交付一系列成为增量的版本，随着每个版本的交付逐步为用户提供更多功能。
2. 由第一个增量到第n个增量。运用增量模型时，第一个增量往往是核心产品，满足了最基本的需求，许多附加的特性（一些是已知的，一些是未知的）没有提供，客户使用核心产品并进行仔细评估，根据评估结果指定下一个增量计划，每一个增量的交付都会重复这一过程，直到最终的产品产生。
3. 优点：对于在业务截止日期之前完成实施的不可用人员配置非常有用。 用于规划管理技术风险。
4. 缺点：专注于交付每个增量的运营产品。早期的增量很容易被"忽略"。

演化模型：在需求把握不好的时候

1.  原型开发：
   1. 客户定义软件的基本任务，但没有定义软件的详细功能和特性需求。开发人员对算法的效率，操作系统的适用性和人机交互方面没有把握。可以采用原型开发范式。
   2. 原型开发范式：沟通-->快速策划-->建模快速设计-->构建原型-->部署交付及反馈-->沟通。一次循环下来，可以根据利益相关者的反馈信息，进一步精炼对软件的需求，使得开发者逐步清楚用户的需求。
   3. 构建的原型系统可能太慢了，太大了，太难用了。最后可能会被废弃，或演化为实际系统。
   4. 缺陷：
      1. 利益相关者看到了软件的工作版本，没有察觉到软件是随意搭建的，开发者没有考虑到软件质量和长期可维护性。不愿意重建软件。
      2. 作为软件工程师，为了让原型软件快速运行起来，采用了折衷手段，使用不合适的操作系统或程序设计语言，低效的算法，开发者可能会适应这些选择，使得不完美的选择成为系统的组成部分

螺旋模型：

1. 演进式软件过程模型，结合了原型的迭代性质和瀑布模型的可控性和系统性特点，采用循环的方式逐步加深系统定义和实现的深度，降低风险，其次 确定一系列里程碑作为支撑点，确保利益相关者认可是可行的且可令各方满意的。
2. 螺旋第一圈表示概念开发项目，经过多个迭代，直到概念开发的结束，新产品继续沿着螺旋向外延伸，成为新产品开发项目不断演进。
3. 当螺旋以这种方式进行下去，可以永远保持可操作性，直到软件产品的生命周期结束，每当有变更，过程总是可以找到合适的入口点启动。在这个过程中，开发者和客户可以更好的理解和应对风险，把原型作为降低风险的机制，在每一个阶段始终考虑技术风险。
4. 缺陷是依赖大量的风险评估专家。

#### （6）统一过程【主要看课件，书上提到的东西很少】，首先是一种开发过程，是一种迭代增量的开发过程，按照管理的角度将其分为几个阶段，在每一个阶段中有多个任务流并发执行。

1. "用例驱动、以架构为中心、迭代和增量"的软件流程，与统一建模语言(UML)紧密结合

   1. 用例驱动：用例如何驱动开发：a. 捕获功能需求 b. 根据用例识别类 c.实施用例 d.测试用例

      ​					用例扮演的角色：1. 是规划迭代开发的基础 2. 是用户手册的基础 3. 可能的销售单位

   2. 软件架构包含以下重大决策：

      1. 软件系统的组织  
      2. 选择结构元素及其接口，通过这些元素及其接口组成系统，以及这些元素之间的协作中指定的行为
      3. 将结构和行为元素组合成逐渐变大的子系统
      4. 指导这个组织的架构风格：这些元素及其界面，它们的协作和组成。

   3. 软件生命周期的两个角度

      1. 管理视角：处理财务，战略，商业和人员
      2. 工程视角：处理分析，设计，实施和其他方面

   4. 统一过程的五个阶段：起始 细化 构建 转换 生产

      1. 起始阶段：客户沟通 策划活动
      2. 细化阶段 沟通，通用模型建模活动，细化阶段扩展了初始阶段的用例，扩展了软件的五种视图：用例模型，需求模型，设计模型，实现模型，部署模型
      3. 构建阶段：与通用软件过程中的构建活动相同
      4. 转换阶段：构建活动后期阶段及通用部署阶段
      5. 生产阶段：与通用过程的部署活动一致
      6. 五个阶段不是顺序执行而是阶段性并发进行

### 敏捷开发

#### （7）为什么要使用敏捷开发，敏捷开发的目的，为了应对什么样的情形

1. 什么是敏捷：对变化的有效（快速和适应性）反应 所有利益相关者之间的有效沟通 将客户吸引到团队中 组织团队，使其能够控制所执行的工作 屈服。。。 快速、增量地交付软件

2. 敏捷过程：由客户对所需内容（方案）的描述驱动 认识到计划是短暂的 迭代开发软件，重点关注施工活动 提供多个"软件增量" 随着变化的发生而适应

3. 敏捷12条原则：

   1. 尽早持续交付有价值的软件让客户满意
   2. 即使是开发后期也欢迎需求变更。
   3. 经常交付可运行软件，交付间隔越短越好
   4. 整个项目开发期间，业务人员与开发人员必须天天在一起工作
   5. 围绕有积极性的个人构建项目，给他们所需环境和支持，信任他们能够完成工作
   6. 面对面交谈是最富有效果和效率的信息传递方法
   7. 可运行软件是进度的首要度量标准
   8. 敏捷过程提倡可持续开发，责任人，开发者和用户应长期保持稳定的开发速度
   9. 不断关注优秀的技能和好的设计
   10. 简单是必要的
   11. 最好的架构，需求，和设计出自于 自组织团队。
   12. 每隔一段时间，团队会反省如何才能更有效地工作，调整自己的行为。

4. 敏捷开发的目的，为了应付怎样的情形：

   市场情况变化迅速，最终用户需求不断变更，新的竞争威胁毫无征兆出现，很多情况下我们无法充分定义需求，所以需要足够敏捷去响应不断变化，无法确定的商业环境。

#### （8）极限编程XP：1. 极限编程大致会被分为几个阶段（4个），2.极限编程里面所使用的开发及时和传统有点区别。传统开发中主要使用的是用例，极限编程中主要使用的是用户故事。【内容是差不多的，都是从用户的角度来描述。不同：尺度、描述方法角度、手段不同】 

1. 极限编程的四个阶段：
   1. 策划：倾听用户故事，表明优先级，分组。**项目速度**是指第一个发行版本的客户故事数。
   2. 设计：遵循KIS（保持简洁）原则，使用简单设计，而不是负责的表述。
   3. 编码：开发对所有故事的编码，并对每个故事进行单元测试。**结对编程**，一个人专注编码细节，一个人确保编码遵循特定标准，确保故事相关代码满足单元测试，并根据故事进行验证。
   4. 测试：使用一个自动实施的框架，每当代码发生修改，进行即使测试，将个人的单元测试组织到一个通用测试集，进行系统的集成和测试，方便为XP团队提供连续的进展指示。
2. 与传统开发过程的区别：传统开发中使用 用例，而极限编程中使用 用户故事（将要开发的软件所需要的输出，特性，及功能）

### 需求工程

#### （9）需求工程的步骤……（起始、获取、细化……）。在每一个步骤里核心的任务分别是什么（第八版教材里面可以做一参考）。细化的目标：开发一个精确的需求模型，来说明软件工程特征和信息的某个方面

1. 需求工程：致力于不断理解需求的大量任务和技术。从软件过程的角度看，开始于沟通，持续到建模。

2. 有哪些需求；

   1. functional requirement :  Capabilities Dynamic behaviour  Data manipulation

   2. Non-functional technical requirements:Operational security
      Safety
      Availability
      Reliability
      Maintainability
      Ergonomics
      Performance
      Constraints

   3. Non-technical requirements: 

      Contractual milestones 

      Required methods and techniques

3. 需求工程的七个步骤：
   1. 起始（Inception）：提出一系列问题以建立对问题的基本理解，谁要解决方案，期望解决方案的性质，利益相关者和开发人员之间初步交流合作的效果。

   2. 获取（elicitation）：从所有利益相关者那里获取需求

   3. 细化（elaboration）：开发一个精确的需求模型，说明软件的功能，特征，信息的各个方面。

   4. 协商（negotiation）：开发人员与客户就可交互系统达成一致

   5. 规格说明（specification)：可以有好多种形式：原型，形式化数学模型，文档，使用场景等等

       软件需求规格说明包括：项目目的，适用人群，总体描述包括产品特性用户特性，系统特性，外部接口需求，其他非功能需求如性能 安全 保密等等。

   6. 确认（validation)：一个审查机制寻找各种解释冲突，不清楚，错误的地方。

   7. 需求管理（Requirements management）

4. 质量功能部署（QFD) ：质量功能部署（QFD）是一种质量管理技术，可将客户的需求转化为软件的技术要求。QFD专注于通过软件工程过程最大限度地**提高客户满意度。**
   1. 三种需求：normal，expected，exciting
   2. 功能部署：确定系统所属的每个功能的价值
   3. 价值分析：确定需求的相对优先级

#### （10）需求建模的方法：（4个）。以面向对象的方法为主。

需求模型的类型：基于场景，类，行为，流。p125

需求建模的方法 一种是结构化分析，一种是面向对象分析。

基于场景的元素：用例文本，用例图，活动图，泳道图，UML

行为元素：状态图，顺序图

基于类的元素：类图，分析包（对外可见的元素为加号，对外隐藏的元素为减号，给定的包访问 #），CRC模型，协作图

**用例**：用于描述使用者如何通过系统达成目的。用例充当一种软件建模工具，用于确定系统的功能和遇到错误的解决办法。

**operation** 操作：操作是在对象接收消息时调用的对象过程。

#### （11）对于行为模型的建模，主要用到两种工具：状态图、顺序图。状态图描述的是什么东西：描述的是系统的状态，类的状态（什么是状态，状态是描述的外部可见、可以观察到的不同的行为模式），顺序图展示的是交互过程，事物与事物之间的交互过程。（和顺序图比较类似的是协作图）状态图一定有一个起点、一个或多个重点、用箭头表示状态的迁移，状态里面有名称、动作

CRC，Class-Responsibility-Collaborator 类-职责-协作者 建模：表示类的标准索引卡片集合，卡片上包括类，职责，协作者。（了解）

### 设计

#### （12）良好设计的三个特征：（第八版166页12.1.1章节）设计应当实现包含在需求中的明确需求并满足相关者期望的隐含需求、可读可理解、全貌………

良好设计的三个特征：

1. 设计应当实现**所有**包含在需求模型中的明确需求，必须满足利益相关者所期望的**隐藏需求**。
2. 对于编码者，测试者以及随后的软件维护者，设计应当是可读的，可理解的指南。
3. 设计应当提供软件的全貌。

#### （13）设计模型有哪些类型，需要从哪几个角度进行设计模型的构建：（4个）。每一种模型描述的是什么东西（第八版164页）

设计模型的构建的角度：

1. 数据设计或类设计：将类模型转化为设计类的实现和软件实现所要求的数据结构
2. 体系结构设计：定义主要结构化元素之间的关系
3. 接口设计：软件与协作系统之间，软件和使用人员之间如何通信
4. 构件级设计：将软件体系结构的结构化元素变换为对软件构建的过程性描述。

设计模型有哪些类型：

1. 数据设计元素：data design element，建立在高抽象上，在客户的角度。
2. 体系结构设计元素：architecture design element 相当于房屋平面图
3. 接口设计元素:interface design element 相当于房屋的门窗，外部设施详细绘图
4. 构件级设计元素：component design element 每个房间设计详图
5. 部署级元素：deployment design element 软件功能和子系统如何在支持软件的物理计算环境分布。

#### （14）设计的概念，重点掌握：重构（173页，什么是重构，为什么要来重构）、体系结构的设计（185页，什么是体系结构）、构件级的设计（208页，什么是构件）

什么是重构：是一种重新组织的技术，简化构件的设计无需改变其功能或行为。

为什么要重构：检查设计的冗余性，没有使用的设计元素，低效的或不必要的算法，拙劣的不恰当的数据结构和其他设计的不足，修改这些不足以得到更好的设计。消除代码退化。

什么是体系结构：体系结构并非可运行的软件，是一种表达，能够使你

1. 对设计在满足既定需求方面的有效性进行分析

 	2. 在设计变更相对容易的阶段，考虑体系结构可能的选择方案
 	3. 降低与软件构建相关的风险。

什么是构件：系统中模块化的，可部署的，可替换的部件。

#### （15）设计的基本原则（9种），根本核心的原则：开关原则（重点掌握），什么是开关原则，哪一种设计会体现开关原则。其他原则要做一了解（至少知道名字）

9种设计的基本原则（知道名字即可）：开闭原则，Liskov替换原则，依赖倒置原则，接口分离原则，发布复用等价性原则，共同封装原则，共同复用原则，SRP，。。。

开闭原则：构件对外延具有开放性，对修改具有封闭性。

![image-20220101155748581](D:/Typora/blog/picture/XCnTqgBe6AJtLvR.png)

要是要添加新的车辆，不用再修改Driver，把ICar抽离出去作为一个接口，使其继承于。这图是个类图。

#### （16）内聚性和耦合性，什么是类聚。什么是耦合。模块之间希望是高类聚，低耦合。依据这种原则设计出的模块有什么样的特点和优势

内聚性:（**Cohesion**） 内聚意味着组件或类仅封装彼此密切相关以及与类或组件本身密切相关的属性和操作

耦合性：（**Coupling**）类相互联系程度的定性度量

Level of coupling 从低到高

content 一个模块依赖另一个模块工作

common 共享全局数据

control  一个模块控制另一个模块

stamp  共享复合数据结构

data 参数定期共享数据，准确获得信息无需知道数据结构

routine call

external



模块之间最好是 高内聚，低耦合。

优势：内聚性越高，耦合性越低，系统越简单，构件实现、测试、维护起来越容易。



### 界面设计

#### （17）界面设计的三个黄金规则：

三个黄金规则：

1. 将用户置于控制之下
2. 减少用户的记忆负担
3. 使界面/接口保持一致

#### （18）界面设计的模型：1. 用户模型，描述的是最终用户的一个轮廓，2.用户的心理模型，用户的脑海里对系统产生的印象期望，3.实现模型，实现模型尽可能和用户的心理模型是一致的

用户模型：对所有系统用户的轮廓

设计模型：用户模型的设计实现

心理模型：用户的脑海里对系统产生的印象期望

实现模型：组合了计算机系统的外在表现，结合了所有用来描述系统的语法和语义，尽可能与用户心理模型一致，融合用户模型。



19年考题 the content of user interface analysis:

user analysis, task analysis, content analysis, environment analysis

#### （19）界面的设计过程：4个活动（了解）

界面设计，用户、任务、环境分析，界面验证，实施

四个活动构成一次迭代

### 测试

#### （20）测试的目的：证明软件有错，尽可能在交付给用户之前发现错误

测试的目的：证明软件有错误，尽可能在交付给用户前发现错误

#### （21）测试分成哪几个主要的测试的阶段：1. 单元测试，2.集成测试，3.确认测试，4.系统测试，

主要的测试阶段：

单元测试

​	集成测试（自顶向下测试（深度优先），自底向上测试（测试簇），回归测试（新加入的模块改变了数据流的路径，引进了新的IO，保证新加入的模块不影响测试过的模块，所以要返回去在测试一次），冒烟测试：项目团队频繁对项目进行测试，进行彻底的测试，使其足够暴漏问题，可以自顶向下，也可以自底向上）

​	

确认测试（确认软件功能和软件需求相符合）

系统测试（不仅有软件工程师的参与，恢复测试，使其发生故障，验证能否恢复，安全测试，压力测试，按非正常的数量，频率执行系统，性能测试，部署测试）

与构建过程相反

![image-20220101162620510](D:/Typora/blog/picture/image-20220101162620510-16410265667312.png)

#### （22）测试技术：白盒测试、黑盒测试。什么是白盒测试（369页），什么是黑盒测试（376页）白盒测试重点掌握基本路径测试，黑盒测试主要掌握等价类划分和边界值测试（黑盒测试不考）

白盒测试：利用作为构件级设计的一部分所描述的控制结构来生成测试用例。可以确保所有独立路径都被测试一次，对所有逻辑判定取真和假两个方面，对上下边界及可操作范围内执行所有循环，检验内部数据结构确保有效性。

黑盒测试：侧重于软件的功能需求，使工程师设计出可以测试程序所有功能需求的输入条件集。

白盒测试基本路径测试：

1. 画流图：部分步骤如果没有分支 可以合并成一个节点。
2. 独立路径的数量等于环复杂性，V = E - N +2（E是边数，N是节点）  V = P+1 P是判定节点数， V = 域的数量


综合题的三个部分：1. 需求的部分，根据题目的要求进行建模。2.设计，使用开关原则来完成一些内容的设计或程序构件的设计。3.测试，一小段程序进行流图绘制，计算环路复杂度